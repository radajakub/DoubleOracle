var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DoubleOracle","category":"page"},{"location":"#DoubleOracle","page":"Home","title":"DoubleOracle","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DoubleOracle.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [DoubleOracle]","category":"page"},{"location":"#DoubleOracle.ActionSet","page":"Home","title":"DoubleOracle.ActionSet","text":"ActionSet\n\nSet of actions of a single player. Store names and assign ids for internal representation.\n\nFields\n\nplayer: Player owning the set of actions\n   n: Number of actions in the set\n ids: Vector of assigned integer ids\nidtoname: Map translating an integer id to an action name\nnametoid: Map translating name of action to the assigned id\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.ActionSet-Tuple{Player, Vector{String}}","page":"Home","title":"DoubleOracle.ActionSet","text":"ActionSet(player::Player, actionnames::Vector{String})\n\nConstruct ActionSet for player containing action with names as in actionnames.\n\nExamples\n\njulia> ActionSet(Player(1), [\"A\", \"B\", \"C\"])\nActions of Player 1: [1] A | [2] B | [3] C |\n\njulia> ActionSet(Player(2), [\"f\", \"e\", \"d\"])\nActions of Player 2: [1] f | [2] e | [3] d |\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.Algorithm","page":"Home","title":"DoubleOracle.Algorithm","text":"Algorithm\n\nAbstract type representing solving algorithms of a game in the Game Theory\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.Game","page":"Home","title":"DoubleOracle.Game","text":"Game\n\nAbstract type uniting all types of games in Game Theory.\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.LinearProgram","page":"Home","title":"DoubleOracle.LinearProgram","text":"LinearProgram\n\nSubtype of Algorithm representing exact solution of a Normal-Form game by linear programming.\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.MatrixGame","page":"Home","title":"DoubleOracle.MatrixGame","text":"MatrixGame\n\nSolve and represent solution of a Matrix game with matrix u. Solution is made by a standard linear program for two-player zero-sum Normal-form games. Both outcome and an equilibrium strategy is saved for both players. Note that this can be only a solution of a subgame, not necessarily the whole NFG.\n\nFields\n\noutcomes: 2-tuple with game outcomes for each respective player\nstrategies: 2-tuple with en equilibrium strategies (probability distribution over rows/columns Δ(A)) for each respective player\n\nExample\n\njulia> u = [1 -1; -1 1];\njulia> MatrixGame(u)\nMatrixGame results:\n→ outcome of the Nash Equilibrium: (0.0, -0.0)\n→ strategy of row player: [0.5, 0.5]\n→ strategy of columne player: [0.5, 0.5]\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.MatrixGame-Tuple{Player}","page":"Home","title":"DoubleOracle.MatrixGame","text":"(mg::MatrixGame)(p::Player)\n\nObtain the outcome value of a player from the MatrixGame structure.\n\nExample\n\njulia> mg = MatrixGame([1 -1; -1 1]);\njulia> mg(Player(1))\n0.0\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.NormalFormGame","page":"Home","title":"DoubleOracle.NormalFormGame","text":"NormalFormGame{T}\n\nModel for a two-player zero-sum game in Normal Form. Here, player 1 tries to maximise the outcome of type T, player 2 minimises it.\n\nFields\n\nname: Name of the NF game\nN: Players of the game\nA: Available actions of each player\nU: Game matrix containing the outcomes for each joint action profile\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.Player","page":"Home","title":"DoubleOracle.Player","text":"Player\n\nRepresent a Player with an integer id in a Game\n\nExamples\n\njulia> Player(1)\nPlayer 1\n\njulia> Player(2)\nPlayer 2\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.Solution","page":"Home","title":"DoubleOracle.Solution","text":"Solution\n\nRepresent solution of the Normal-Form game. In contrast to MatrixGame, this solution corresponds always to the whole NFG.\n\nFields\n\n  name: name of the NormalFormGame (for pretty output)\noutcomes: 2-tuple of outcome for each player\nstrategies: 2-tuple of strategies for each player (strategy is a vector of tuples, where first part is name of action and second is a playing probability in equilibrium)\n\n\n\n\n\n","category":"type"},{"location":"#DoubleOracle.Solution-Tuple{MatrixGame, NormalFormGame}","page":"Home","title":"DoubleOracle.Solution","text":"Solution(mg::MatrixGame, nfg::NormalFormGame)\n\nConstruct Solution in a case where mg contains solution of the whole nfg, i.e. in exact solution by linear programming. Strategies in mg are assumed to be of same length as action sets in nfg.\n\nExample\n\njulia> nfg = load(\"./data/nf_games/matching_pennies.nfg\", NormalFormGame);\njulia> mg = MatrixGame(nfg.u);\njulia> Solution(mg, nfg)\nThe two-player zero-sum Normal-Form game was solved\n\nPlayer 1 gains outcome 0.0 by playing a strategy\n → [1 : 0.5, 2 : 0.5]\n\nPlayer 2 gains outcome -0.0 by playing a strategy\n → [A : 0.5, B : 0.5]\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.Solution-Tuple{Player}","page":"Home","title":"DoubleOracle.Solution","text":"(solution::Solution)(p::Player)\n\nShortcut to obtain outcome of a player present in solution.\n\nExample\n\njulia> solution = Solution(\"test\", (1.0, -1.0), ([(\"A\", 1)], [(\"B\", 1)]));\njulia> solution(Player(2))\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{ActionSet, Integer}","page":"Home","title":"Base.getindex","text":"getindex(A::ActionSet, id::Integer)\n\nRetrieve name of action with assigned id.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> A[3]\n\"C\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{ActionSet, String}","page":"Home","title":"Base.getindex","text":"getindex(A::ActionSet, name::String)\n\nRetrieve id of action named name.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> A[\"B\"]\n2\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{MatrixGame, Player}","page":"Home","title":"Base.getindex","text":"getindex(mg::MatrixGame, p::Player)\n\nObtain the strategy of a player from the MatrixGame structure.\n\nExample\n\njulia> mg = MatrixGame([1 -1; -1 1]);\njulia> mg[Player(1)]\n2-element Vector{Float64}:\n 0.5\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{NormalFormGame, Integer, Integer}","page":"Home","title":"Base.getindex","text":"getindex(nfg::NormalFormGame, a1::Integer, a2::Integer)\n\nObtain nfg outcome by playing joing action profile (a1, a2)\n\nExample\n\njulia> nfg = load(\"./data/nf_games/mathing_pennies.nfg, NormalFormGame);\njulia> nfg[1, 1]\n1\n\njulia> nfg[\"1\", \"B\"]\n-1\n\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{Solution, Player}","page":"Home","title":"Base.getindex","text":"getindex(solution::Solution, p::Player)\n\nShortcut to obtain strategy of a player present in solution.\n\nExample\n\njulia> solution = Solution(\"test\", (1.0, -1.0), ([(\"A\", 1)], [(\"B\", 1)]));\njulia> solution[Player(2)]\n1-element Vector{Tuple{String, Float64}}:\n (\"B\", 1.0)\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{Union{Tuple{Vararg{T}}, AbstractVector{<:T}} where T, Player}","page":"Home","title":"Base.getindex","text":"getindex(container::AbstractVecOrTuple, player::Player)\n\nGet the element on index of a player inside the container. The container has to be either Vector or Tuple The index corresponds to id of the player.\n\nExamples\n\njulia> names = (\"John\", \"Thomas\", \"Agatha\")\n(\"John\", \"Thomas\", \"Agatha\")\njulia> names[Player(3)]\n\"Agatha\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.iterate","page":"Home","title":"Base.iterate","text":"iterate(A::ActionSet)\n\nGo through ids of all actions in fixed order.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> collect(A)\n4-element Vector{Any}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"#Base.length-Tuple{ActionSet}","page":"Home","title":"Base.length","text":"length(A::ActionSet)\n\nReturn number of actions in A.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> length(A)\n4\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.allnames-Tuple{ActionSet}","page":"Home","title":"DoubleOracle.allnames","text":"allnames(A::ActionSet)\n\nReturn list of action names from A in the same order as ids\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> allnames(A)\n[\"A\", \"B\", \"C\", \"D\"]\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.createplayers-Tuple{Integer}","page":"Home","title":"DoubleOracle.createplayers","text":"createplayers(n::Integer)\n\nCreate a vector of n Players with ids i  1n\n\nExamples\n\njulia> createplayers(3)\n3-element Vector{Player}:\n Player 1\n Player 2\n Player 3\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.load-Tuple{String, Type{NormalFormGame}}","page":"Home","title":"DoubleOracle.load","text":"load(filepath::String, type::Type{NormalFormGame})\n\nLoad and return a game of type (i.e. NormalFormGame, ...) from file located in the filesystem at filepath. The extension of the filepath must correspond to the game type (e.g. NormalFormGame - nfg).\n\nEXample\n\njulia> nfg = load(\"./data/nf_games/mathing_pennies.nfg, NormalFormGame)\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.pairstrategies-Tuple{Vector{String}, Vector{Float64}}","page":"Home","title":"DoubleOracle.pairstrategies","text":"pairstrategies(names::Vector{String}, probs::Vector{Float64})\n\nMerge names and probs (probabilities) in such a way that first element in names is joined with first element in probs into a tuple and so on.\n\nExample\n\njulia> names = [\"A\", \"B\"];\njulia> probs = [1.0, 0.0];\njulia> pairstrategies(names, probs)\n2-element Vector{Tuple{String, Float64}}:\n (\"A\", 1.0)\n (\"B\", 0.0)\n\n\n\n\n\n","category":"method"},{"location":"#DoubleOracle.solve-Tuple{NormalFormGame, Type{LinearProgram}}","page":"Home","title":"DoubleOracle.solve","text":"solve(nfg::NormalFormGame, ::Type{LinearProgram})\n\nSolve the NormalFormGame by linear programming and return the outcome and equilibrium strategies.\n\n\n\n\n\n","category":"method"}]
}
