var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"game/#Game","page":"Game definition","title":"Game","text":"","category":"section"},{"location":"game/","page":"Game definition","title":"Game definition","text":"This parts documents loading and generating a new game and auxiliary functions for this process.","category":"page"},{"location":"game/#Player","page":"Game definition","title":"Player","text":"","category":"section"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Structure and functions representing Players in the game. Player is used mainly for printing and for indexing in more complicated structures.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"One or more Players can be created at once.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Player\ncreateplayers(::Integer)","category":"page"},{"location":"game/#DoubleOracle.Player","page":"Game definition","title":"DoubleOracle.Player","text":"Player\n\nRepresent a Player with an integer id in a Game\n\nExamples\n\njulia> Player(1)\nPlayer 1\n\njulia> Player(2)\nPlayer 2\n\n\n\n\n\n","category":"type"},{"location":"game/#DoubleOracle.createplayers-Tuple{Integer}","page":"Game definition","title":"DoubleOracle.createplayers","text":"createplayers(n::Integer)\n\nCreate a vector of n Players with ids i  1n\n\nExamples\n\njulia> createplayers(3)\n3-element Vector{Player}:\n Player 1\n Player 2\n Player 3\n\n\n\n\n\n","category":"method"},{"location":"game/","page":"Game definition","title":"Game definition","text":"As said above, a Player structure can be used to easier indexing without the need of remembering ids.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Base.getindex(::Base.AbstractVecOrTuple, ::Player)","category":"page"},{"location":"game/#Base.getindex-Tuple{Union{Tuple{Vararg{T}}, AbstractVector{<:T}} where T, Player}","page":"Game definition","title":"Base.getindex","text":"getindex(container::AbstractVecOrTuple, player::Player)\n\nGet the element on index of a player inside the container. The container has to be either Vector or Tuple The index corresponds to id of the player.\n\nExamples\n\njulia> names = (\"John\", \"Thomas\", \"Agatha\")\n(\"John\", \"Thomas\", \"Agatha\")\njulia> names[Player(3)]\n\"Agatha\"\n\n\n\n\n\n","category":"method"},{"location":"game/#ActionSet","page":"Game definition","title":"ActionSet","text":"","category":"section"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Structure that provides an abstraction over a set of available actions of a single player. It gives easy translations between names given by user in the input file and ids that are used as indices to strategy vectors and utility matrix.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"ActionSet\nActionSet(::Player, ::Vector{String})","category":"page"},{"location":"game/#DoubleOracle.ActionSet","page":"Game definition","title":"DoubleOracle.ActionSet","text":"ActionSet\n\nSet of actions of a single player. Store names and assign ids for internal representation.\n\nFields\n\nplayer: Player owning the set of actions\nn: Number of actions in the set\nids: Vector of assigned integer ids\nidtoname: Map translating an integer id to an action name\nnametoid: Map translating name of action to the assigned id\n\n\n\n\n\n","category":"type"},{"location":"game/#DoubleOracle.ActionSet-Tuple{Player, Vector{String}}","page":"Game definition","title":"DoubleOracle.ActionSet","text":"ActionSet(player::Player, actionnames::Vector{String})\n\nConstruct ActionSet for player containing action with names as in actionnames.\n\nExamples\n\njulia> ActionSet(Player(1), [\"A\", \"B\", \"C\"])\nActions of Player 1: [1] A | [2] B | [3] C |\n\njulia> ActionSet(Player(2), [\"f\", \"e\", \"d\"])\nActions of Player 2: [1] f | [2] e | [3] d |\n\n\n\n\n\n","category":"method"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Some standard container functions are overloaded to make indexing and iteration simpler.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Base.getindex(::ActionSet, ::Integer)\nBase.getindex(::ActionSet, ::String)\nBase.length(::ActionSet)\nBase.iterate(::ActionSet)","category":"page"},{"location":"game/#Base.getindex-Tuple{ActionSet, Integer}","page":"Game definition","title":"Base.getindex","text":"getindex(A::ActionSet, id::Integer)\n\nRetrieve name of action with assigned id.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> A[3]\n\"C\"\n\n\n\n\n\n","category":"method"},{"location":"game/#Base.getindex-Tuple{ActionSet, String}","page":"Game definition","title":"Base.getindex","text":"getindex(A::ActionSet, name::String)\n\nRetrieve id of action named name.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> A[\"B\"]\n2\n\n\n\n\n\n","category":"method"},{"location":"game/#Base.length-Tuple{ActionSet}","page":"Game definition","title":"Base.length","text":"length(A::ActionSet)\n\nReturn number of actions in A.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> length(A)\n4\n\n\n\n\n\n","category":"method"},{"location":"game/#Base.iterate-Tuple{ActionSet}","page":"Game definition","title":"Base.iterate","text":"iterate(A::ActionSet)\n\nGo through ids of all actions in fixed order.\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> collect(A)\n4-element Vector{Any}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"game/","page":"Game definition","title":"Game definition","text":"To obtain ::Vector{String} of names of all actions in the set in the exact order as the ids, use the allnames function.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"allnames(::ActionSet)","category":"page"},{"location":"game/#DoubleOracle.allnames-Tuple{ActionSet}","page":"Game definition","title":"DoubleOracle.allnames","text":"allnames(A::ActionSet)\n\nReturn list of action names from A in the same order as ids\n\nExamples\n\njulia> A = ActionSet(Player(1), [\"A\", \"B\", \"C\", \"D\"])\nActions of Player 1: [1] A | [2] B | [3] C | [4] D |\n\njulia> allnames(A)\n[\"A\", \"B\", \"C\", \"D\"]\n\n\n\n\n\n","category":"method"},{"location":"game/#Game-2","page":"Game definition","title":"Game","text":"","category":"section"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Game","category":"page"},{"location":"game/#DoubleOracle.Game","page":"Game definition","title":"DoubleOracle.Game","text":"Game\n\nAbstract type uniting all types of games in Game Theory.\n\n\n\n\n\n","category":"type"},{"location":"game/","page":"Game definition","title":"Game definition","text":"First used game is the well-known Normal-Form game represented as an utility matrix. We focus on two-player zero-sum NF games.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"NormalFormGame","category":"page"},{"location":"game/#DoubleOracle.NormalFormGame","page":"Game definition","title":"DoubleOracle.NormalFormGame","text":"NormalFormGame{T}\n\nModel for a two-player zero-sum game in Normal Form. Here, player 1 tries to maximise the outcome of type T, player 2 minimises it.\n\nFields\n\nname: Name of the NF game\nN: Players of the game\nA: Available actions of each player\nU: Game matrix containing the outcomes for each joint action profile\n\n\n\n\n\n","category":"type"},{"location":"game/","page":"Game definition","title":"Game definition","text":"There are two possible ways how to create a NormalFormGame structure. First is loading a prepared game from a text file ending with .nfg and following a format given by examples in /data/ folder. Second is setting some parameters and constraints to generate a random game.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"load(::String, ::Type{NormalFormGame})\ngenerate(::Type{NormalFormGame};)","category":"page"},{"location":"game/#DoubleOracle.load-Tuple{String, Type{NormalFormGame}}","page":"Game definition","title":"DoubleOracle.load","text":"load(filepath::String, type::Type{NormalFormGame})\n\nLoad and return a game of type (i.e. NormalFormGame, ...) from file located in the filesystem at filepath. The extension of the filepath must correspond to the game type (e.g. NormalFormGame - nfg).\n\nEXample\n\njulia> nfg = load(\"./data/nf_games/mathing_pennies.nfg, NormalFormGame)\n\n\n\n\n\n","category":"method"},{"location":"game/#DoubleOracle.generate-Tuple{Type{NormalFormGame}}","page":"Game definition","title":"DoubleOracle.generate","text":"generate(::Type{NormalFormGame}, A1min, A1max, A2min, A2max, minutil, maxutil, utilstep)\n\nGenerate random Normal-Form game with given parameters.\n\nFields\n\nA1min::Integer: minimum number of actions of player 1 (default 2)\nA1max::Integer: maximum number of actions of player 1 (default 5)\nA2min::Integer: minimum number of actions of player 2 (default 2)\nA2max::Integer: maximum number of actions of player 2 (default 5)\nminutil<:Real: minimum utility possible for player 1\nmaxutil<:Real: maxium utility possible for player 1\nutilstep<:Real: minimum difference between two different utility values for player 1\n\nExamples\n\njulia> generate(NormalFormGame; A1min=2, A1max=2, A2min=3, A2max=3, minutil=1, maxutil=1)\n===== generated =====\nplayers: Player 1 | Player 2\n\nActions of Player 1: [1] 1 | [2] 2 |\nActions of Player 2: [1] 1 | [2] 2 | [3] 3 |\n\nU (2 × 3)\n    1   2   3\n   -------------\n 1 | 1 | 1 | 1 |\n   -------------\n 2 | 1 | 1 | 1 |\n   -------------\n\n\n\n\n\n","category":"method"},{"location":"game/","page":"Game definition","title":"Game definition","text":"To avoid always writing nfg.U[a1, a2] a shortcut is provided.","category":"page"},{"location":"game/","page":"Game definition","title":"Game definition","text":"Base.getindex(::NormalFormGame, ::Integer, ::Integer)","category":"page"},{"location":"game/#Base.getindex-Tuple{NormalFormGame, Integer, Integer}","page":"Game definition","title":"Base.getindex","text":"getindex(nfg::NormalFormGame, a1::Integer, a2::Integer)\n\nObtain nfg outcome by playing joing action profile (a1, a2)\n\nExamples\n\njulia> nfg = load(\"./data/nf_games/mathing_pennies.nfg, NormalFormGame);\njulia> nfg[1, 1]\n1\n\njulia> nfg[\"1\", \"B\"]\n-1\n\n\n\n\n\n\n","category":"method"},{"location":"doc_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"doc_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"solution/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"This part summarizes funtions and structures providing solutions for games defined in previous section.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"Algorithm","category":"page"},{"location":"solution/#DoubleOracle.Algorithm","page":"Solutions","title":"DoubleOracle.Algorithm","text":"Algorithm\n\nAbstract type representing solving algorithms of a game in the Game Theory\n\n\n\n\n\n","category":"type"},{"location":"solution/#Matrix-Game","page":"Solutions","title":"Matrix Game","text":"","category":"section"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"This serves as a general solver for matrix game with arbitrary size, not necessarily corresponding to size of the actual Normal-Form game. It solves a linear program for the passed matrix u (game or subgame) and saves the outcomes and equilibrium strategies of both players.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"MatrixGame","category":"page"},{"location":"solution/#DoubleOracle.MatrixGame","page":"Solutions","title":"DoubleOracle.MatrixGame","text":"MatrixGame\n\nSolve and represent solution of a Matrix game with matrix u. Solution is made by a standard linear program for two-player zero-sum Normal-form games. Both outcome and an equilibrium strategy is saved for both players. Note that this can be only a solution of a subgame, not necessarily the whole NFG.\n\nFields\n\noutcomes: 2-tuple with game outcomes for each respective player\nstrategies: 2-tuple with en equilibrium strategies (probability distribution over rows/columns Δ(A)) for each respective player\n\nExamples\n\njulia> u = [1 -1; -1 1];\njulia> MatrixGame(u)\nMatrixGame results:\n→ outcome of the Nash Equilibrium: (0.0, -0.0)\n→ strategy of row player: [0.5, 0.5]\n→ strategy of columne player: [0.5, 0.5]\n\n\n\n\n\n","category":"type"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"Again, for easier extraction of results, indexing shortcuts are provided.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"(:MatrixGame)(::Player)\nBase.getindex(::MatrixGame, ::Player)","category":"page"},{"location":"solution/#DoubleOracle.MatrixGame-Tuple{Player}","page":"Solutions","title":"DoubleOracle.MatrixGame","text":"(mg::MatrixGame)(p::Player)\n\nObtain the outcome value of a player from the MatrixGame structure.\n\nExamples\n\njulia> mg = MatrixGame([1 -1; -1 1]);\njulia> mg(Player(1))\n0.0\n\n\n\n\n\n","category":"method"},{"location":"solution/#Base.getindex-Tuple{MatrixGame, Player}","page":"Solutions","title":"Base.getindex","text":"getindex(mg::MatrixGame, p::Player)\n\nObtain the strategy of a player from the MatrixGame structure.\n\nExamples\n\njulia> mg = MatrixGame([1 -1; -1 1]);\njulia> mg[Player(1)]\n2-element Vector{Float64}:\n 0.5\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"solution/#Solution","page":"Solutions","title":"Solution","text":"","category":"section"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"Solution represents the final solution of the whole Normal-Form game. It holds final equilibria strategies and outcomes.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"Solution\nSolution(::MatrixGame, ::NormalFormGame)","category":"page"},{"location":"solution/#DoubleOracle.Solution","page":"Solutions","title":"DoubleOracle.Solution","text":"Solution\n\nRepresent solution of the Normal-Form game. In contrast to MatrixGame, this solution corresponds always to the whole NFG.\n\nFields\n\n  name: name of the NormalFormGame (for pretty output)\noutcomes: 2-tuple of outcome for each player\nstrategies: 2-tuple of strategies for each player (strategy is a vector of tuples, where first part is name of action and second is a playing probability in equilibrium)\n\n\n\n\n\n","category":"type"},{"location":"solution/#DoubleOracle.Solution-Tuple{MatrixGame, NormalFormGame}","page":"Solutions","title":"DoubleOracle.Solution","text":"Solution(mg::MatrixGame, nfg::NormalFormGame)\n\nConstruct Solution in a case where mg contains solution of the whole nfg, i.e. in exact solution by linear programming. Strategies in mg are assumed to be of same length as action sets in nfg.\n\nExamples\n\njulia> nfg = load(\"./data/nf_games/matching_pennies.nfg\", NormalFormGame);\njulia> mg = MatrixGame(nfg.u);\njulia> Solution(mg, nfg)\nThe two-player zero-sum Normal-Form game was solved\n\nPlayer 1 gains outcome 0.0 by playing a strategy\n → [1 : 0.5, 2 : 0.5]\n\nPlayer 2 gains outcome -0.0 by playing a strategy\n → [A : 0.5, B : 0.5]\n\n\n\n\n\n","category":"method"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"As always, the shortcuts for easier indexing and uitilization of the Player abstraction.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"(:Solution)(::Player)\nBase.getindex(::Solution, ::Player)","category":"page"},{"location":"solution/#DoubleOracle.Solution-Tuple{Player}","page":"Solutions","title":"DoubleOracle.Solution","text":"(solution::Solution)(p::Player)\n\nShortcut to obtain outcome of a player present in solution.\n\nExamples\n\njulia> solution = Solution(\"test\", (1.0, -1.0), ([(\"A\", 1)], [(\"B\", 1)]));\njulia> solution(Player(2))\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"solution/#Base.getindex-Tuple{Solution, Player}","page":"Solutions","title":"Base.getindex","text":"getindex(solution::Solution, p::Player)\n\nShortcut to obtain strategy of a player present in solution.\n\nExamples\n\njulia> solution = Solution(\"test\", (1.0, -1.0), ([(\"A\", 1)], [(\"B\", 1)]));\njulia> solution[Player(2)]\n1-element Vector{Tuple{String, Float64}}:\n (\"B\", 1.0)\n\n\n\n\n\n","category":"method"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"When probabilities are to be joined with corresponding action names, the pairstrategies function is advised to be used.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"pairstrategies(::Vector{String}, ::Vector{Float64})","category":"page"},{"location":"solution/#DoubleOracle.pairstrategies-Tuple{Vector{String}, Vector{Float64}}","page":"Solutions","title":"DoubleOracle.pairstrategies","text":"pairstrategies(names::Vector{String}, probs::Vector{Float64})\n\nMerge names and probs (probabilities) in such a way that first element in names is joined with first element in probs into a tuple and so on.\n\nExamples\n\njulia> names = [\"A\", \"B\"];\njulia> probs = [1.0, 0.0];\njulia> pairstrategies(names, probs)\n2-element Vector{Tuple{String, Float64}}:\n (\"A\", 1.0)\n (\"B\", 0.0)\n\n\n\n\n\n","category":"method"},{"location":"solution/#Exact-solve-by-linear-programming","page":"Solutions","title":"Exact solve by linear programming","text":"","category":"section"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"LinearProgram","category":"page"},{"location":"solution/#DoubleOracle.LinearProgram","page":"Solutions","title":"DoubleOracle.LinearProgram","text":"LinearProgram\n\nSubtype of Algorithm representing exact solution of a Normal-Form game by linear programming.\n\n\n\n\n\n","category":"type"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"To obtain an exact solution of a given Normal-Form game, use the function solve with LinearProgram parameter.","category":"page"},{"location":"solution/","page":"Solutions","title":"Solutions","text":"solve(::NormalFormGame, ::Type{LinearProgram})","category":"page"},{"location":"solution/#DoubleOracle.solve-Tuple{NormalFormGame, Type{LinearProgram}}","page":"Solutions","title":"DoubleOracle.solve","text":"solve(nfg::NormalFormGame, ::Type{LinearProgram})\n\nSolve the NormalFormGame by linear programming and return the outcome and equilibrium strategies.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DoubleOracle","category":"page"},{"location":"#DoubleOracle-package","page":"Home","title":"DoubleOracle package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DoubleOracle package contining solution methods for some parts of game theory using exact methods and variations of Oracle methods.","category":"page"},{"location":"#Table-of-contents-for-easy-navigation","page":"Home","title":"Table of contents for easy navigation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
